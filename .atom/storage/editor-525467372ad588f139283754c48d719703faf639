{"mode":"editor","version":1,"windowDimensions":{"x":4,"y":22,"width":1436,"height":878},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/tehgeekmeister/udacity/udacity","buffers":[{"text":"\"\"\"Media model definitions.\"\"\"\n\n# TODO(piotr): rename to media.py once old module is gone.\n\nimport logging\nimport re\n\nfrom google.appengine.api import images\nfrom google.appengine.ext import blobstore\nfrom google.appengine.ext import ndb\n\nfrom src.core import trove\n\n\n@ndb.non_transactional\n@ndb.tasklet\ndef deleteBlobSafely(blob_key):\n    if blob_key:\n        try:\n            yield blobstore.delete_async(blob_key)\n        except:\n            logging.error('Failed to delete orphaned blob: %s', blob_key, exc_info=True)\n\n\nclass MediaProperty(ndb.LocalStructuredProperty):\n    _writes_require_controller = True\n\n    def __init__(self, *args, **kwargs):\n        super(MediaProperty, self).__init__(*args, **kwargs)\n        if not issubclass(self._modelclass, Media) or self._modelclass is Media:\n            raise TypeError('MediaProperty model class must be a subclass of Media')\n\n\nclass Media(trove.Model):\n    SCHEMA_VERSION = 1\n    blob_key = ndb.BlobKeyProperty(indexed=False)\n    last_upload_time = ndb.DateTimeProperty(indexed=False)\n    size = ndb.IntegerProperty(indexed=False)\n    duration = ndb.FloatProperty(indexed=False)\n    md5_hash = ndb.StringProperty(indexed=False)\n\n    \"\"\" Simple enumeration of states for the media object.\n\n    - Waiting: The initial state for any media.  Some workflows may create a Media object where\n            user intervention is still needed after uploading to the blobstore (i.e. field labels,\n            3rd party account credentials).  Ideally the information field will have some helpful\n            text on what to do next\n    - Processing: The media is in process.  This is extremely generic: It may be in the middle\n            of the upload process locally to App Engine or queued in a 3rd party processing\n            pipeline.  The key is that the object is in flux at this point.\n    - Completed:  The final state of a media object.  This will correspond to either success or\n            failure.  If the media pipeline failed for any reason, something should be stored in\n            the state information for this value\n    \"\"\"\n    processing_state = ndb.StringProperty(\n        choices=['WAITING', 'PROCESSING', 'COMPLETED'],\n        default='WAITING')\n\n    # In case of needed clarification, gives the reason.  Potential massive service/debug response\n    processing_state_information = ndb.TextProperty()\n\n    # Steps currently in progress, waiting on callbacks; values are specific to media types\n    processing_steps = ndb.TextProperty(\n        repeated=True, choices=['youtube_video', 'zencoder_transcoding'])\n\n    # State information for media processing pipelines\n    @property\n    def processing_successful(self):\n        return self.processing_state == 'COMPLETED' and not self.processing_state_information\n\n    def updateStatus(self, msg=None, done=False):\n        \"\"\"Modifies the internal state / messaging based on whether or not processing has completed.\n        Any message associated with the state is interpreted as either informational (in the\n        not-yet-completed state) or an error message (if it has completed).\n\n        To rephrase: If a message is supplied once the pipeline has finished, it will be\n        interpreted as a failure message (as success shouldn't require any additional information)\n\n        *WARNING* For convenience, 'msg' may be passed positionally in various parts of the code.\n\n        Args:\n            msg: string. The supplied message associated with this new status update.\n            done:  boolean. Whether or not this status update marks to completion of the processing\n                pipeline for this media object\n        \"\"\"\n        if self.processing_state == 'COMPLETED':\n            if done and msg:\n                if self.processing_state_information:\n                    self.processing_state_information += '; ' + msg\n                else:\n                    self.processing_state_information = msg\n        else:\n            self.processing_state = 'COMPLETED' if done else 'PROCESSING'\n            self.processing_state_information = msg\n\n    def startProcessingStep(self, step):\n        self.processing_steps.append(step)\n\n    def finishProcessingStep(self, step):\n        self.processing_steps = [s for s in self.processing_steps if s != step]\n\n    @ndb.tasklet\n    def deleteBlobs(self):\n        yield deleteBlobSafely(self.blob_key)\n\n\nclass YouTubeVideoMediaHashIndex(trove.Model):\n    \"\"\"Stores a reference to a youtube_id based on an md5 hash.\"\"\"\n    md5_hash = ndb.StringProperty(required=True)\n    youtube_id = ndb.TextProperty(required=True)\n\n\nclass EmbeddedMedia(Media):\n    container_key = ndb.KeyProperty(indexed=False)\n    container_property = ndb.TextProperty()\n\n\nclass DocumentMedia(EmbeddedMedia):\n    pass\n\n\nclass S3CdnReference(trove.Model):\n    \"\"\"A reference to some media on a CDN.\"\"\"\n    s3_uri = ndb.TextProperty()\n\n    @property\n    def uri(self):\n        from src.gateways import hub\n        bucket, resource = hub.s3.parseUri(self.s3_uri)\n        return (\n            ('http://%s/%s' % (bucket, resource)) if bucket.endswith('.udacity-data.com')\n            else hub.s3.getUrl(bucket, resource))\n\n\nclass TranscodedMedia(Media):\n    encoder_nonce = ndb.TextProperty()  # Don't project this to the client!\n    encoder_job_id = ndb.TextProperty()\n    # Transcodings map file types to S3CdnReferences.\n    transcodings = trove.LocalModelMapProperty(S3CdnReference, name='cdn_transcodings')\n\n    @ndb.tasklet\n    def deleteBlobs(self):\n        from src.gateways import hub\n        try:\n            yield [super(TranscodedMedia, self).deleteBlobs()] + [\n                hub.s3.delete(self.transcodings[file_type].s3_uri)\n                for file_type in self.transcodings]\n        except:\n            logging.error('Failed to delete orphaned S3 files', exc_info=True)\n\n\nclass VideoMedia(TranscodedMedia):\n    SCHEMA_VERSION = 2\n    TRANSCODING_FORMATS = {\n        '720p.mp4': {\n            'audio_bitrate': 160,\n            'audio_sample_rate': 48000,\n            'height': 720,\n            'width': 1280,\n            'max_frame_rate': 30,\n            'video_bitrate': 5000,\n            'h264_profile': 'main',\n            'h264_level': 3.1\n        },\n        '480p.mp4': {\n            'audio_bitrate': 96,\n            'audio_sample_rate': 44100,\n            'height': 480,\n            'width': 854,\n            'max_frame_rate': 30,\n            'video_bitrate': 2000,\n            'h264_profile': 'main',\n        },\n        '480p.ogg': {\n            'format': 'ogg',\n            'audio_codec': 'vorbis',\n            'audio_bitrate': 96,\n            'audio_sample_rate': 44100,\n            'video_codec': 'theora',\n            'height': 480,\n            'width': 854,\n            'max_frame_rate': 30,\n            'video_bitrate': 2000,\n        },\n    }\n\n    youtube_id = ndb.TextProperty()\n    captions = MediaProperty(DocumentMedia)\n\n\nclass ImageMedia(Media):\n    serving_url = ndb.StringProperty()\n\n    def generateHighPerformanceImageServingUrl(self):\n        if self.blob_key:\n            # size=0 forces the url to return a non-resized version of the image\n            url = images.get_serving_url(self.blob_key, secure_url=False, size=0)\n            # make http://something become just //something to avoid mixed-content warnings\n            self.serving_url = re.sub(r'^http:', '', url)\n            self.updateStatus(done=True)\n\n            data_futures = [\n                blobstore.fetch_data_async(self.blob_key, i, i + blobstore.MAX_BLOB_FETCH_SIZE - 1)\n                for i in xrange(0, self.size, blobstore.MAX_BLOB_FETCH_SIZE)]\n            image_data = ''.join([future.get_result() for future in data_futures])\n            image = images.Image(image_data=image_data)\n            self.serving_url += '#w=%d&h=%d' % (image.width, image.height)\n        else:\n            self.updateStatus('No image data', done=True)\n\n\nclass AudioMedia(TranscodedMedia):\n    SCHEMA_VERSION = 1\n    TRANSCODING_FORMATS = {\n        'default.mp3': {'format': 'mp3', 'audio_codec': 'mp3'},\n        'default.ogg': {'format': 'ogg', 'audio_codec': 'vorbis'},\n    }\n\n    legacy_transcodings = trove.LocalModelMapProperty(Media, name='transcodings')\n\n    @ndb.tasklet\n    def deleteBlobs(self):\n        yield [super(AudioMedia, self).deleteBlobs()] + [\n            prop._get_value(self.legacy_transcodings).deleteBlobs()\n            for prop in self.legacy_transcodings._properties.itervalues()\n        ]\n\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":45},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tehgeekmeister/udacity/udacity/udacityu/src/models/media2.py","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"323d5aaa2ca4250202a59badf7ca660ba94ddd2d","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":45,"softTabs":true,"displayBuffer":{"id":46,"softWrap":false,"editorWidthInChars":152,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tehgeekmeister/udacity/udacity/udacityu/src/models/media2.py","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/tehgeekmeister/udacity/udacity/udacityu/src/models/media2.py","focused":false,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"find-and-replace":{"projectViewState":{"findHistory":["AKIAIVTJY6CGXNCDHM7A"],"replaceHistory":[],"pathsHistory":[],"modelState":{"useRegex":false,"caseSensitive":false}},"resultsModelState":{"useRegex":false,"caseSensitive":false}},"fuzzy-finder":{"/Users/tehgeekmeister/udacity/udacity/udacityu/src/models/media2.py":1400455930863},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":803984369},"tree-view":{"directoryExpansionStates":{},"selectedPath":"/Users/tehgeekmeister/udacity/udacity/udacityu","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}